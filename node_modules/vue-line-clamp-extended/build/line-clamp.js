"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isFunction = function (fn) { return typeof fn === 'function'; };
var clamp = function (el, binding, vnode) {
    if (!binding.value) {
        throw new Error('Directive options are missing');
    }
    var originalText = binding.value.text || '';
    // number of lines that should remain visible after clamping
    var lineCount = binding.value.lines || 3;
    // expanded can be a function that returns boolean, or a boolean straight up
    var expanded = binding.value.expanded;
    var isExpanded = isFunction(expanded) ? expanded(el, binding) : !!expanded;
    // needs to happen first, we don't have the right height later
    var lineHeight = window && window.getComputedStyle(el).lineHeight;
    el.style.maxHeight = "calc(" + lineHeight + " * " + lineCount + ")";
    // content needs to be wrapped in something so we can get diffs in height
    var span = document.createElement('span');
    span.innerHTML = originalText;
    el.innerHTML = '';
    el.appendChild(span);
    // if bindings indicate text should be expanded we reset text and height
    if (isExpanded) {
        span.textContent = originalText;
        el.style.maxHeight = 'initial';
        return;
    }
    // notify the parent component whether the text overflows or not
    // TODO: should this trigger event on elm instead of context?
    if (vnode.context) {
        vnode.context.$emit('is-expandable', span.offsetHeight > el.clientHeight);
    }
    // cut out words from the end until it all fits into view
    while (span.offsetHeight > el.clientHeight) {
        var text = span.textContent || originalText;
        span.textContent = text.replace(/\W*\s(\S)*$/, '...');
    }
};
exports.lineClamp = {
    inserted: clamp,
    update: clamp,
};
//# sourceMappingURL=line-clamp.js.map